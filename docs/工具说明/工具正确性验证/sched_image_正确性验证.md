# sched_image 正确性验证
## 0.准备工作：

学习使用LTTng 来监测数据;

学习将LTTng生成的文件在compass上跑出来,并分析;

### 0.1.LTTng学习使用:

[linux下 LTTng使用详细说明_no package 'liburcu' found-CSDN博客](https://blog.csdn.net/mao_hui_fei/article/details/120654095)

```c
lttng create my-session
lttng enable-event --kernel sched_switch
lttng add-context --kernel --type pid --type tid
lttng track --kernel --pid <pid>
lttng track --kernel --tid <tid>
lttng start
# 运行你想监控的进程或线程
lttng stop
lttng view
lttng destroy
```

### 0.2.trace compass

[Trace Compass User Guide - LTTng Kernel Analysis (eclipse.org)](https://archive.eclipse.org/tracecompass/doc/stable/org.eclipse.tracecompass.doc.user/LTTng-Kernel-Analysis.html#Control_Flow_View)

![1720660193068](./images/1720660193068.png)
## 1.sched_image

为了完成以上三步测试与数据关联工作，需要设计一个测试用例，使用该测试用例可以测试sched_image工具的逻辑正确性，并通过和lttng工具测试的结果进行对比，判断sched_image数据正确性；

sched_image工具关注的是进程被调度时的延迟，具体点就是进程从被唤醒到上cpu这段时间的延迟，为了比较数据的正确性，我们采用lttng，将lttng跟踪点放在`sched_switch`、`sched_wakeup`、`sched_wakeup_new`。

### 1.1 测试用例test_sched

#### 1.1.1 测试用例设计思路:

测试用例主要思路是：创建多个线程去执行CPU密集型任务，查看这些线程在被调度时的延迟情况，与此同时采用sysbench工具产生高负载环境，产生大量调度事件，增加系统整体调度频率。

测试用例主要思路

- 对测试进程进行绑核，绑定在cpu4上；
- 创建16个线程去执行CPU密集型任务，营造出调度的环境；
- 线程执行完任务后退出；

在执行测试用例前需要用sysbench创建36个进程执行大量的CPU密集型任务，去提高系统负载，此时再通过`sched_image()`监测该环境下的线程组的行为。

#### 1.1.2 测试脚本:

在通过测试用例对sched_image工具进行逻辑正确性的验证之后,需要验证sched_image工具采集到的数据是否是可靠的;

这里通过一个测试脚本实现sched_image工具和lttng同时监测测试用例的数据，并将数据导出；

由于lttng输出的结果是详细的单个线程每次发生调度时的数据，为了符合sched_image的输出结果，设计了python脚本对lttng原始数据进行计算处理；

### 1.2 结果分析：

通过测试用例和测试脚本，对sched_image工具的逻辑正确性和数据正确性进行了评估，本小节将针对输出的数据进行正确性检测；

#### 1.2.1.逻辑正确性

通过脚本，可以获取到sched_image监测测试用例进程的在被调度时的延迟情况；由于本次测试仅关注单个进程或线程组的情况，忽略对整个系统当前的调度延迟情况的验证；

下面是测试用例在执行了相关操作后的输出，可以看出测试用例创建了30255~30270共计16个线程来执行cpu密集型任务,在sched_image的输出中信息中也可以查看到相关线程的调度延迟情况,证明了工具可以监测线程调度延迟;

```
    #PID29705绑定CPU4：√
    #PID29705 被绑定在以下cpu上: 4 
test_proc进程的TGID:29705        PID:29705       CPU_id:4
输入任意数字继续程序的运行:1
程序开始执行...
  #1.PID:30255 TGID:29705
  #CPU密集型

  #1.PID:30256 TGID:29705
  #CPU密集型

  #1.PID:30257 TGID:29705
  #CPU密集型

  #1.PID:30258 TGID:29705
  #CPU密集型

  #1.PID:30259 TGID:29705
  #CPU密集型

  #1.PID:30260 TGID:29705
  #CPU密集型

  #1.PID:30261 TGID:29705
  #CPU密集型

  #1.PID:30262 TGID:29705
  #CPU密集型

  #1.PID:30263 TGID:29705
  #CPU密集型

  #1.PID:30264 TGID:29705
  #CPU密集型

  #1.PID:30270 TGID:29705
  #CPU密集型

  #1.PID:30269 TGID:29705
  #CPU密集型

  #1.PID:30268 TGID:29705
  #CPU密集型

  #1.PID:30267 TGID:29705
  #CPU密集型

  #1.PID:30266 TGID:29705
  #CPU密集型

  #1.PID:30265 TGID:29705
  #CPU密集型
    #30263退出
    #30260退出
    #30256退出
    #30269退出
    #30261退出
    #30262退出
    #30255退出
    #30264退出
    #30257退出
    #30270退出
    #30266退出
    #30258退出
    #30259退出
    #30268退出
    #30267退出
```

sched_image工具监测到的结果:

```
SCHEDULE ----------------------------------------------------------------------------------------------------------------------
TIME      TGID    PID     PRIO  | P_AVG_DELAY(ms) S_AVG_DELAY(ms) | P_MAX_DELAY(ms) S_MAX_DELAY(ms) | P_MIN_DELAY(ms) S_MIN_DELAY(ms) |
21:55:14  29705   30263   120   | 59.439293       4.486027        | 72.030970       4629.971274     | 37.406719       0.000882        |
21:55:14  29705   30265   120   | 59.277075       4.486027        | 74.783045       4629.971274     | 14.999412       0.000882        |
21:55:14  29705   30267   120   | 59.200207       4.486027        | 71.837144       4629.971274     | 28.286873       0.000882        |
21:55:14  29705   29705   120   | 0.004809        4.486027        | 0.004809        4629.971274     | 0.004809        0.000882        |
21:55:14  29705   30256   120   | 60.343717       4.486027        | 80.016246       4629.971274     | 48.131959       0.000882        |
21:55:14  29705   30269   120   | 60.828869       4.486027        | 104.015723      4629.971274     | 44.202620       0.000882        |
21:55:14  29705   30264   120   | 62.809482       4.486027        | 202.431816      4629.971274     | 41.031998       0.000882        |
21:55:14  29705   30257   120   | 60.246384       4.486027        | 96.055618       4629.971274     | 47.910671       0.000882        |
21:55:14  29705   30260   120   | 59.768547       4.486027        | 92.002259       4629.971274     | 25.142902       0.000882        |
21:55:14  29705   30259   120   | 59.845333       4.486027        | 108.348840      4629.971274     | 19.561148       0.000882        |
21:55:14  29705   30258   120   | 60.156634       4.486027        | 122.003156      4629.971274     | 13.581161       0.000882        |
21:55:14  29705   30262   120   | 58.650610       4.486027        | 104.011502      4629.971274     | 0.019427        0.000882        |
21:55:14  29705   30270   120   | 60.002680       4.486027        | 72.012554       4629.971274     | 44.008079       0.000882        |
21:55:14  29705   30261   120   | 59.596674       4.486027        | 72.089872       4629.971274     | 29.450209       0.000882        |
21:55:14  29705   30268   120   | 60.397836       4.486027        | 82.019640       4629.971274     | 36.338791       0.000882        |
21:55:14  29705   30255   120   | 60.714674       4.486027        | 77.784962       4629.971274     | 48.009419       0.000882        |
21:55:14  29705   30266   120   | 59.679530       4.486027        | 76.011399       4629.971274     | 39.815206       0.000882        |

```



#### 1.2.2 数据正确性

通过将sched_image获取的数据同lttng作对比，便可得到  sched_image工具获取到的调度延迟数据是否正确，同时也验证了sched_image工具在逻辑上的正确性。以下是sched_image和lttng获取到的数据进行比对：

在时间【21:55:14】时，sched_image以及lttng产生了如下数据：

- **线程30259**：
	- 平均时延
		- sched_image：59.845333 ms
		- lttng：60.044201ms
		- 二者相差误差在0.198868ms
	- 最大时延
		- sched_image：108.348840 ms
		- lttng：108.34258ms
		- 二者相差误差在0.00626ms
	- 最小时延
		- sched_image：19.561148 ms
		- lttng：19.57056ms
		- 二者相差误差在0.009412ms
- **线程3025966**：

- 平均时延
	- sched_image：59.679530 ms
	- lttng：59.530130ms
	- 二者相差误差在0.1494ms
- 最大时延
	- sched_image：76.011399 ms
	- lttng：76.00721ms
	- 二者相差误差在0.004189ms
- 最小时延
	- sched_image：39.815206 ms
	- lttng：39.82198ms
	- 二者相差误差在0.006774ms
- **线程3025969**：
- 平均时延
	- sched_image：60.736575 ms
	- lttng：60.496016 ms
	- 二者相差误差在0.2405598ms
- 最大时延
	- sched_image：104.015723 ms
	- lttng：104.01492  ms
	- 二者相差误差在0.000803ms
- 最小时延
	- sched_image：44.202620 ms
	- lttng：44.19760ms
	- 二者相差误差在0.00502ms

由于数据量过于庞大，仅从中抽取以上三条数据作为对比，两种监测数据之差可以看出，sched_image采集到的数据和lttng官方工具采集到的数据是完全一致的（误差小于0.01%），故得到结论sched_image工具的逻辑正确性与数据正确性完全成立；



### 1.3 关键数据点的关联关系

由于每秒钟产生调度事件十分繁多，sched_image工具关注于每秒钟线程调度延迟的最大、最小以及平均值。可以将这三个指标作为测评单个进程调度延迟性能的指标，而不关注进程单次调度行为而产生的延迟（这一部分可以通过keytime_image中的上下CPU功能来监测其具体行为）。

sched_image采集到的这个调度延迟数据指标可以和keytime_image相关联，用于研究当线程发生上cpu行为时，该线程此次调度所等待的时间。
